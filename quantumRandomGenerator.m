function rnd_n = quantumRandomGenerator(n,int_type)
                                    % This code returns an array with "n" REAL RANDOM NUMBERS 
                                    % with values between [1-"n"] and NO REPETITION
                                    % These are REAL-TIME generated by the
                                    % ANU Quantum Random Numbers Server
                                    % from the Australian National
                                    % University (http://qrng.anu.edu.au/index.php)
                                    
%%% Code adapted by Gorka Zubia Garea the 18-09-2019 from the ORIGINAL
%%% "get_1024" downloded the 18-09-2019 from http://qrng.anu.edu.au/get_1024.m

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%% MAIN PROGRAM  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% First comprobations
if n < 0
    fprintf("ERROR: 'n' needs to be greater than zero\nThe inserted value was: %d\n",n);
    return;
else
    if strcmp(int_type,'uint8') ~=1 && strcmp(int_type,'uint16') ~=1
        fprintf("ERROR: the two accepted data types are 'uint8 and uint16\n");
        return;
    end
    if (n > 255) && (strcmp(int_type,'uint16') ~=1)
            fprintf("ERROR: the selected data type %d is too small for the amount of random numbers to be created %d\n",int_type,n);
            return;
    elseif (n > 0 && n <= 255) && (strcmp(int_type,'uint8') ~=1)
            fprintf(["WARNING: the selected data type %d is bigger that the required for the amount of random numbers to be created %d.\n"... 
                     "It is recomendable to use a smaller data type (uint8) for a faster performance\n"],int_type,n);
    end
end


%% Variable definition
qrng_web  = 'http://qrng.anu.edu.au/API/jsonI.php?length=1024&type='; % ANU Quantum Random Numbers Server zerbitzariaren URL helbidea
qrng_web  = strcat(qrng_web,int_type);
rnd_n     = zeros(1,n);                                               % Aukeratutako n ausazko zenbakiak ([1-"n"]) gordeko duen arraya
ret       = [];                                                       % Zerbitzariaren erantzuna gordeko du
idx       = 1;
n_dw_blk  = 6;                                                        % Deskargatuko diren 1024 zenbaki bloke kopurua aldi bakoitzean
rnd       = 1:(1024*n_dw_blk);                                        % Deskargatuko diren zenbakiak gordeko ditu
ok_rnd    = [];                                                       % Aldi bakoitzean deskargatutako [1-"n"] tartean errepetiziorik gabeko zenbaki arraya
aux       = 1:n;
parpoolHasieratu;
for i=1:n_dw_blk %%% cell// structaren hasieraketa parfora azkarragoa izateko
    ret{i}.type    = [];
    ret{i}.length  = [];
    ret{i}.data    = [];
    ret{i}.success = [];
end

%% Real random numbers are downloaded and evaluated
while 1
    %%%% Random numbers are downloaded in blocks of 1024 "int_type" numbers %%%
    parfor j=1:n_dw_blk
            ret{j}  = webread(qrng_web); % JavaScript petition to the server
        if ret{j}.success ~= 1
            disp('Error in JSON parameters.')
        end
    end
    
    offset = 1;
    for j=1:n_dw_blk
        rnd(offset:offset+1023) = ret{j}.data;      % The 1024 random numbers are saved
        offset                  = offset + 1023 +1;
    end
    
    ok_rnd = unique(rnd(rnd<=n),'stable');     % Comprobation that any of the random numbers is between [1-"n"] and repetitions of numbers are discarded
    
    %%% The numbers which are NOT already in the rnd_n are saved %%%
    len                = length(ok_rnd(~ismember(ok_rnd,rnd_n)))-1;
    rnd_n(idx:idx+len) = ok_rnd(~ismember(ok_rnd,rnd_n));
    idx                = idx + len +1;
    if idx == n
        rnd_n(n) = aux(~ismember(aux,rnd_n));
        return;    % if the index is in the last position, finish the function
    elseif idx>n
        return;
    end
    
    clear ok_rnd;
end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%% USER DEFINED FUNCTIONS %%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%% PARPOOL INITIALISE %%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function parpoolHasieratu
% Seek core number
ncores = feature('numCores');
disp([num2str(ncores) ' cores found'])

% Seek CPU number
import java.lang.*;
r=Runtime.getRuntime;
ncpus=r.availableProcessors;
disp([num2str(ncpus) ' cpus found'])

% Paralell pool size
npool = ncores;

% Parallel pool opens if needed (it may be already opened)
if ncpus>1

    disp('Opening parallel pool...')
    
    % first check if there is a current pool
    poolobj=gcp('nocreate');
    
    % If there is no pool create one
    if isempty(poolobj)
        command=['parpool(' num2str(npool) ');'];
        disp(command);
        eval(command);
    else
        poolsize=poolobj.NumWorkers;
        fprintf('A pool of %d workers already exists\n',poolsize);
    end
    
end
clear r;